{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

() recv_internal() {
}

const ASCII_SIZE = 128;

forall X -> int is_null (X x) asm "ISNULL";

;; Building cell linked-list from the list-style list
cell build_list(tuple head) inline {
  (builder element, head) = uncons(head);
  cell result = element.end_cell();

  while(~ head.is_null()) {
    (element, head) = uncons(head);
    result = element.store_ref(result).end_cell();
    dump_stack();
  }

  return result;
}

cell shifting(int shift, slice text_slice) {
  int char = 0;
  builder shifted = begin_cell().store_uint(0, 32);
  tuple head = null();

  while(1) {
    repeat(text_slice.slice_bits() / 8) {
      char = text_slice~load_uint(8);
    
      ;; only for a-z A-Z
      ;; if(((char >= 65) & (char <= 90)) | ((char >= 97) & (char <= 122))) {
      ;;   shifted~store_uint(((((((char - 97) < 0) * 32) + (char - 97) + shift) >= 26) ? (shift - 26) : (shift)) + char, 8);
      ;; } else {
      ;;   shifted~store_uint(char, 8);
      ;; }

      shifted~store_uint((((char + shift) >= ASCII_SIZE) ? (shift - ASCII_SIZE) : (shift)) + char, 8);
    }

    head = cons(shifted, head);

    if(text_slice.slice_refs()) {
      shifted = begin_cell();
      text_slice = (text_slice~load_ref()).begin_parse();
    } else {
      return build_list(head);
    }
  }

  return build_list(head);
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {

  slice text_slice = text.begin_parse();

  if(((shift % ASCII_SIZE) == 0) | text_slice.slice_empty?()) {
    return text;
  }

  shift %= ASCII_SIZE;
  
  if(shift < 0) {
    shift += ASCII_SIZE;
  }

  text_slice~load_uint(32);
  return shifting(shift, text_slice);
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
  slice text_slice = text.begin_parse();

  if(((shift % ASCII_SIZE) == 0) | text_slice.slice_empty?()) {
    return text;
  }

  shift %= ASCII_SIZE;
  
  if(shift < 0) {
    shift += ASCII_SIZE;
  }

  shift = ASCII_SIZE - shift;

  text_slice~load_uint(32);
  return shifting(shift, text_slice);
}

